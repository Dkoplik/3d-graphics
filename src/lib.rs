//! Небольшая библиотека для работы с 3D графикой.
//!
//! Содержит все необходимые классы для представления 3D моделей в пространстве,
//! а так же вспомогательные классы по типу освещения и камеры для отрисовки этих
//! моделей. Модели поддерживают шейдинг и текстурирование.

use egui::Color32;

// Модуль с реализациями заданных структур.
pub mod classes3d;

// TODO это какой-то костыль, надо убрать
// Экспортируем ProjectionType для использования в других модулях
pub use classes3d::camera3::ProjectionType;

// ========================================
// Определение основных структур библиотеки
// ========================================

/// Точка в 3D пространстве с координатами `x`, `y`, `z`.
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Point3 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}

/// Вектор (направление) в 3D пространстве с координатами `x`, `y`, `z`.
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Vec3 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}

/// Однородный (homogeneous) вектор в 3D пространстве.
///
/// По сути, этот вектор является 4D вектором с координатами `(x, y, z, w)`, но каждый такой вектор соответсвует
/// обычному 3D вектору `(x/w, y/w, z/w)`. 4-ая координата необходима для проецирования и позволяет использовать
/// матрицы преобразования 4x4 над этим вектором.
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct HVec3 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}

// TODO нужна структура CoordFrame, которая будет задавать координатную систему для объекта (например, локальные координаты модели)

/// Плоскость в 3D пространстве.
///
/// Плоскость задаётся точкой, через которую проходит, и нормалью к этой точке.
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Plane {
    /// Точка, через которую проходит плоскость.
    pub origin: Point3,
    /// Нормаль плоскости в виде единичного вектора.
    pub normal: Vec3,
}

/// Линия в 3D пространстве.
///
/// Линия задаётся точкой, через которую проходит, и направлением.
#[derive(Debug, Clone, Copy)]
pub struct Line3 {
    /// Точка, через которую проходит прямая.
    pub origin: Point3,
    /// Направление прямой в виде единичного вектора.
    pub direction: Vec3,
}

/// Полигон модели в 3D пространстве.
///
/// Полигон может быть **любым** многоугольником. Полигоны предпалагаются для использования
/// внутри Mesh'ей, поэтому хранят в себе не сами точки, а индексы вершин, которые соединяют.
#[derive(Debug, Clone)]
pub struct Polygon3 {
    /// Индексы вершин, которые этот полигон соединяет.
    vertexes: Vec<usize>,
}

/// Mesh модели.
///
/// Mesh представляет собой набор вершин (точек) и полигонов.
#[derive(Debug, Clone)]
pub struct Mesh {
    // TODO создать файл с реализацией этого класса.
    /// Все вершины Mesh'а модели.
    ///
    /// Этот вектор хранит все 3D точки, являющиеся вершинами рассматриваемой модели.
    /// Точки заданы в локальных координатах относительно центра модели.
    vertexes: Vec<Point3>,
    /// Все полигоны Mesh'а модели.
    ///
    /// Для оптимизации хранения, полигоны задаются индексами вершин из `vertexes`, а не копиями вершин.
    polygons: Vec<Polygon3>,
}

/// Модель (объект) в 3D пространстве.
#[derive(Debug, Clone)]
pub struct Model3 {
    // TODO модель должна содержать свои коодринаты, меш, нормали и текстуру
    /// Центр модели, вокруг которого она строится.
    origin: Point3,
}

/// Сцена в 3-х мерном пространстве с 3-х мерными объектами (моделями).
#[derive(Debug, Clone)]
pub struct Scene {
    /// Модели на сцене.
    pub models: Vec<Model3>,
}

/// Камера в 3-х мерном пространстве.
pub struct Camera3 {
    /// Позиция камеры в простанстве.
    pub position: Point3,
    /// В какую сторону камера смотрит.
    pub direction: Vec3,
    /// Направление вверх для камеры.
    pub up: Vec3,
    /// Field of View.
    pub fov: f32,
    /// Соотношение сторон.
    pub aspect_ratio: f32,
    /// С какого расстояния от точки камеры отображать объекты.
    pub near_plane: f32,
    /// До какого расстояния отображать объекты.
    pub far_plane: f32,
    /// Тип проекции камеры.
    pub projection_type: ProjectionType,
}

/// Матрица преобразования 4x4 для 3D пространства.
///
/// Поскольку матрица 4x4, к ней нужны 4D вектора для применения преобразования.
/// Наша матрица транспонирована по сравнению со стандартными реализациями, например,
/// элементы для сдвига координат находятся у нас в последней строке матрицы, а не в последнем столбце.
/// Иными словами, при применении матрицы к вектору, матрица умножается справа, а не слева:
///```
///                 | m11 m12 m13 m14 |
/// (x, y, z, w) x  | m21 m22 m23 m24 |
///                 | m31 m32 m33 m34 |
///                 | m41 m42 m43 m44 |
/// ```
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Transform3D {
    /// Матрица преобразования 4x4 в виде одномерного массива в row-major порядке.
    pub m: [f32; 16],
}

// TODO Пока что не уверен, нужен ли этот класс.
/// Аффинное 2D преобразование
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Transform2D {
    // Матрица аффинного преобразования:
    // [a, d, 0]
    // [b, e, 0]
    // [c, f, 1]
    pub a: f32,
    pub b: f32,
    pub c: f32,
    pub d: f32,
    pub e: f32,
    pub f: f32,
}

// ===================================
// Определение trait'ов для библиотеки
// ===================================

pub struct RenderStyle {
    pub vertex_color: Color32,
    pub vertex_radius: f32,
    pub edge_color: Color32,
    pub edge_width: f32,
}

impl Default for RenderStyle {
    fn default() -> Self {
        Self {
            vertex_color: Color32::BLACK,
            vertex_radius: 2.5,
            edge_color: Color32::BLACK,
            edge_width: 1.0,
        }
    }
}
